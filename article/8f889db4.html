<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author"><title>架构 · yuxue's blog</title><meta name="description" content="架构设计的目的
为了高性能、高可用、可扩展，所以要做架构设计

能够给出这个答案，说明已经有了一定的架构经历或者基础，毕竟确实很多架构设计都是冲着高性能、高可用……等“高XX”的目标去的。
但往往持有这类观点的架构师和设计师会给项目带来巨大的灾难
架构设计的真正目的通过回顾架构产生的历史背景和原因，"><meta name="og:description" content="架构设计的目的
为了高性能、高可用、可扩展，所以要做架构设计

能够给出这个答案，说明已经有了一定的架构经历或者基础，毕竟确实很多架构设计都是冲着高性能、高可用……等“高XX”的目标去的。
但往往持有这类观点的架构师和设计师会给项目带来巨大的灾难
架构设计的真正目的通过回顾架构产生的历史背景和原因，"><meta name="twitter:site" content="yuxue's blog"><meta name="twitter:title" content="架构"><meta name="twitter:card" content="summary"><meta name="keywords" content="123"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/yuxue-r.io/css/bootstrap.min.css"><link rel="stylesheet" href="/yuxue-r.io/css/font-awesome.min.css"><link rel="stylesheet" href="/yuxue-r.io/css/style.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"><meta name="generator" content="Hexo 7.3.0"></head><body><div class="container" id="stage"><div class="row"><div class="col-sm-3 col-xs-12 side-container invisible" id="side-bar"><div class="vertical-text site-title"><h3 class="site-title-small" tabindex="-1"><a class="a-title" href="/yuxue-r.io/">slience</a></h3><h1 class="site-title-large" tabindex="-1"><a class="a-title" href="/yuxue-r.io/">沉默是金</a></h1><!--h6(onclick="triggerSiteNav()") Trigger--></div><br class="visible-lg visible-md visible-sm"><div class="site-title-links" id="site-nav"><ul><li><a href="/yuxue-r.io/">Home</a></li><li><a href="/yuxue-r.io/archives">Archive</a></li><li><a href="/yuxue-r.io/tags">Tags</a></li><li><a href="/yuxue-r.io/bridge/assets/index-2ab5157f.js"></a></li><li><a href="/yuxue-r.io/bridge/assets/index-7d02bcb5.js"></a></li><li><a href="/yuxue-r.io/bridge/assets/index-7c4f7a9d.js"></a></li><li><a href="/yuxue-r.io/bridge/assets/index-6fce073a.js"></a></li><li class="soc"><a href="https://yuxue-r.github.io/yuxue-r.io/atom.xml" target="_blank" rel="noopener noreferrer" aria-label="RSS"><i class="fa fa-rss">&nbsp;</i></a></li></ul><div class="visible-lg visible-md visible-sm site-nav-footer"><br class="site-nav-footer-br"><footer><p>&copy;&nbsp;2025&nbsp;<a target="_blank" href="https://yuxue-r.github.io/yuxue-r.io" rel="noopener noreferrer">yuxue</a></p><p>Theme&nbsp;<a target="_blank" href="https://github.com/SumiMakito/hexo-theme-typography" rel="noopener noreferrer">Typography</a>&nbsp;by&nbsp;<a target="_blank" href="https://www.keep.moe" rel="noopener noreferrer">Makito</a></p><p>Proudly published with&nbsp;<a target="_blank" href="https://hexo.io" rel="noopener noreferrer">Hexo</a></p></footer></div></div></div><div class="col-sm-9 col-xs-12 main-container invisible" id="main-container"><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post-container"><p class="post-title"><a>架构</a></p><p class="post-meta"><span class="date meta-item">Posted at&nbsp;2025-08-25</span><span class="meta-item"><i class="fa fa-tag"></i><span>&nbsp;</span><a class="a-tag" href="/yuxue-r.io/tags/笔记/" title="笔记">笔记</a><span>&nbsp;</span></span></p><p class="post-abstract"><h1 id="架构设计的目的"><a href="#架构设计的目的" class="headerlink" title="架构设计的目的"></a>架构设计的目的</h1><ul>
<li>为了高性能、高可用、可扩展，所以要做架构设计</li>
</ul>
<p>能够给出这个答案，说明已经有了一定的架构经历或者基础，毕竟确实很多架构设计都是冲着高性能、高可用……等“高XX”的目标去的。</p>
<p>但往往持有这类观点的架构师和设计师会给项目带来巨大的灾难</p>
<h2 id="架构设计的真正目的"><a href="#架构设计的真正目的" class="headerlink" title="架构设计的真正目的"></a>架构设计的真正目的</h2><p>通过回顾架构产生的历史背景和原因，我们可以基本推导出答案：<strong>架构设计的主要目的是为了解决软件系统复杂度带来的问题</strong>。</p>
<ul>
<li>“这么多需求，从哪里开始下手进行架构设计呢？”</li>
</ul>
<p>——通过熟悉和理解需求，识别系统复杂性所在的地方，然后针对这些复杂点进行架构设计。</p>
<ul>
<li>“架构设计要考虑高性能、高可用、高扩展……这么多高XX，全部设计完成估计要1个月，但老大只给了1周时间”</li>
</ul>
<p>——架构设计并不是要面面俱到，不需要每个架构都具备高性能、高可用、高扩展等特点，而是要识别出复杂点然后有针对性地解决问题。</p>
<ul>
<li>“业界A公司的架构是X，B公司的方案是Y，两个差别比较大，该参考哪一个呢？”</li>
</ul>
<p>——理解每个架构方案背后所需要解决的复杂点，然后才能对比自己的业务复杂点，参考复杂点相似的方案。</p>
<p>其次，遵循这条准则能够让“老鸟”架构师<strong>有的放矢，而不是贪大求全</strong>。</p>
<ul>
<li>Docker不是万能的，只是为了解决资源重用和动态分配而设计的</li>
</ul>
<h2 id="简单的复杂度分析案例"><a href="#简单的复杂度分析案例" class="headerlink" title="简单的复杂度分析案例"></a>简单的复杂度分析案例</h2><p>假设我们需要设计一个大学的学生管理系统，其基本功能包括登录、注册、成绩管理、课程管理等。当我们对这样一个系统进行架构设计的时候，首先应识别其复杂度到底体现在哪里。</p>
<p>性能：一个学校的学生大约1 ~ 2万人，学生管理系统的访问频率并不高，平均每天单个学生的访问次数平均不到1次，因此性能这部分并不复杂，存储用MySQL完全能够胜任，缓存都可以不用，Web服务器用Nginx绰绰有余。</p>
<p>可扩展性：学生管理系统的功能比较稳定，可扩展的空间并不大，因此可扩展性也不复杂。</p>
<p>高可用：学生管理系统即使宕机2小时，对学生管理工作影响并不大，因此可以不做负载均衡，更不用考虑异地多活这类复杂的方案了。但是，如果学生的数据全部丢失，修复是非常麻烦的，只能靠人工逐条修复，这个很难接受，因此需要考虑存储高可靠，这里就有点复杂了。我们需要考虑多种异常情况：机器故障、机房故障，针对机器故障，我们需要设计MySQL同机房主备方案；针对机房故障，我们需要设计MySQL跨机房同步方案。</p>
<p>安全性：学生管理系统存储的信息有一定的隐私性，例如学生的家庭情况，但并不是和金融相关的，也不包含强隐私（例如玉照、情感）的信息，因此安全性方面只要做3个事情就基本满足要求了：Nginx提供ACL控制、用户账号密码管理、数据库访问权限控制。</p>
<p>成本：由于系统很简单，基本上几台服务器就能够搞定，对于一所大学来说完全不是问题，可以无需太多关注。</p>
<p>还有其他方面，如果有兴趣，你可以自行尝试去分析。通过我上面的分析，可以看到这个方案的主要复杂性体现在存储可靠性上，需要保证异常的时候，不要丢失所有数据即可（丢失几个或者几十个学生的信息问题不大），对应的架构如下：</p>
<p><img src="https://github.com/yuxue-r/pic/blob/master/2025/1725783793484-e9d01b71-db1c-4b5a-9f3a-a8cd30b8fbaf.png?raw=true" alt="1725783793484-e9d01b71-db1c-4b5a-9f3a-a8cd30b8fbaf.png"></p>
<p>学生管理系统虽然简单，但麻雀虽小五脏俱全，基本上能涵盖软件系统复杂度分析的各个方面，而且绝大部分技术人员都曾经自己设计或者接触过类似的系统，如果将这个案例和自己的经验对比，相信会有更多的收获。</p>
<h1 id="08-架构设计三原则"><a href="#08-架构设计三原则" class="headerlink" title="08 架构设计三原则"></a>08 架构设计三原则</h1><p>相比编程来说，架构设计并没有像编程语言那样的语法来进行约束，更多的时候是面对多种可能性时进行选择。</p>
<p>可是一旦涉及“选择”，就很容易让架构师陷入两难的境地</p>
<p><strong>合适原则、简单原则、演化原则</strong>，架构设计时遵循这几个原则，有助于你做出最好的选择。</p>
<h2 id="合适原则"><a href="#合适原则" class="headerlink" title="合适原则"></a>合适原则</h2><p><strong>合适原则宣言：“合适优于业界领先”</strong></p>
<p><strong>没那么多人，却想干那么多活，是失败的第一个主要原因</strong></p>
<p><strong>没有那么多积累，却想一步登天，是失败的第二个主要原因</strong></p>
<p><strong>没有那么卓越的业务场景，却幻想灵光一闪成为天才，是失败的第三个主要原因</strong></p>
<h2 id="简单原则"><a href="#简单原则" class="headerlink" title="简单原则"></a>简单原则</h2><p><strong>简单原则宣言：“简单优于复杂”</strong></p>
<p>例如设计一个主备方案，如果你用心跳来实现，可能大家都认为这太简单了。但如果你引入ZooKeeper来做主备决策，可能很多人会认为这个方案更加“高大上”一些，毕竟ZooKeeper使用的是ZAB协议，而ZAB协议本身就很复杂。其实，真正理解ZAB协议的人很少（我也不懂），但并不妨碍我们都知道ZAB协议很优秀。</p>
<p>1.结构复杂性</p>
<p>结构上的复杂性存在的第一个问题是，<strong>组件越多，就越有可能其中某个组件出现故障</strong></p>
<p>结构上的复杂性存在的第二个问题是，<strong>某个组件改动，会影响关联的所有组件</strong></p>
<p>结构上的复杂性存在的第三个问题是，<strong>定位一个复杂系统中的问题总是比简单系统更加困难</strong></p>
<p>2.逻辑复杂性</p>
<p>不要把所有的代码和逻辑都扔进一个结构（这里的结构主要指系统）里</p>
<p>以ZooKeeper为例，ZooKeeper本身的功能主要就是选举，为了实现分布式下的选举，采用了ZAB协议，所以ZooKeeper功能虽然相对简单，但系统实现却比较复杂。相比之下，etcd就要简单一些，因为etcd采用的是Raft算法，相比ZAB协议，Raft算法更加容易理解，更加容易实现。</p>
<h2 id="演化原则"><a href="#演化原则" class="headerlink" title="演化原则"></a>演化原则</h2><p><strong>演化原则宣言：“演化优于一步到位”</strong></p>
<p>如果没有把握“软件架构需要根据业务发展不断变化”这个本质，在做架构设计的时候就很容易陷入一个误区：试图一步到位设计一个软件架构，期望不管业务如何变化，架构都稳如磐石</p>
<p><strong>软件架构设计其实更加类似于大自然“设计”一个生物，通过演化让生物适应环境，逐步变得更加强大</strong></p>
<p>软件架构设计同样是类似的过程：</p>
<ul>
<li>首先，设计出来的架构要满足当时的业务需要。</li>
<li>其次，架构要不断地在实际应用过程中迭代，保留优秀的设计，修复有缺陷的设计，改正错误的设计，去掉无用的设计，使得架构逐渐完善。</li>
<li>第三，当业务发生变化时，架构要扩展、重构，甚至重写；代码也许会重写，但有价值的经验、教训、逻辑、设计等（类似生物体内的基因）却可以在新架构中延续。</li>
</ul>
<h1 id="09-架构设计原则案例"><a href="#09-架构设计原则案例" class="headerlink" title="09 架构设计原则案例"></a>09 架构设计原则案例</h1><h2 id="淘宝"><a href="#淘宝" class="headerlink" title="淘宝"></a>淘宝</h2><p>1.最早的版本当时淘宝是买来的，要求快速可用</p>
<p><strong>买一个系统是为了“快速可用”，而买一个轻量级的系统是为了“快速开发”</strong>。因为系统上线后肯定有大量的需求需要做，这时能够快速开发就非常重要</p>
<p>淘宝最开始的时候业务要求就是“快”，因此反过来要求技术同样要“快”，业务决定技术，这里架构设计和选择主要遵循的是“合适原则”和“简单原则”</p>
<p>2.当用户访问量上升之后，淘宝首先把数据库从MySQL更换为了Oracle</p>
<p>此时离刚上线才半年不到，业务飞速发展，最快的方式支撑业务的发展还是去买。如果说第一阶段买的是“方案”，这个阶段买的就是“性能”，这里架构设计和选择主要遵循的还是“合适原则”和“简单原则”</p>
<p>3.Java1.0版本，当时从PHP升级为Java语言</p>
<p>首先因为Java较火，懂得该技术的人相对较多，较好维护，好招人</p>
<p>此时就遵循了三大原则的“演化原则”，通过重构来解决</p>
<p>4.Java2.0版本</p>
<p>Java时代2.0，淘宝做了很多优化工作：数据分库、放弃EJB、引入Spring、加入缓存、加入CDN、采用开源的JBoss。为什么在这个时候要做这些动作？原文作者很好地概括了做这些动作的原因：</p>
<p>这些杂七杂八的修改，我们对数据分库、放弃EJB、引入Spring、加入缓存、加入CDN、采用开源的JBoss，看起来没有章法可循，其实都是围绕着提高容量、提高性能、节约成本来做的。</p>
<p>Oracle再强大，在做like类搜索的时候，也不可能做到纯粹的搜索系统如Solr、Sphinx等的性能，因为这是机制决定的。</p>
<p>5.Java 时代3.0和分布式时代</p>
<h2 id="手机QQ"><a href="#手机QQ" class="headerlink" title="手机QQ"></a>手机QQ</h2><p>手机QQ的发展历程按照用户规模可以粗略划分为4个阶段：十万级、百万级、千万级、亿级，不同的用户规模，IM后台的架构也不同，而且基本上都是用户规模先上去，然后产生各种问题，倒逼技术架构升级。</p>
<p>1.十万级IM 1.X</p>
<p>架构设计遵循的是“合适原则”和“简单原则”</p>
<p>2.百万级IM 2.X</p>
<ul>
<li>以接入服务器的内存为例，单个在线用户的存储量约为2KB，索引和在线状态为50字节，好友表400个好友 × 5字节&#x2F;好友 &#x3D; 2000字节，大致来说，2GB内存只能支持一百万在线用户。</li>
<li>CPU&#x2F;网卡包量和流量&#x2F;交换机流量等瓶颈。</li>
<li>单台服务器支撑不下所有在线用户&#x2F;注册用户。</li>
</ul>
<p>遵循了“合适原则”和“简单原则”</p>
<p>3.千万级IM 3.X</p>
<ul>
<li>同步流量太大，状态同步服务器遇到单机瓶颈。</li>
<li>所有在线用户的在线状态信息量太大，单台接入服务器存不下，如果在线数进一步增加，甚至单台状态同步服务器也存不下。</li>
<li>单台状态同步服务器支撑不下所有在线用户。</li>
<li>单台接入服务器支撑不下所有在线用户的在线状态信息。</li>
</ul>
<p>遵循了“演化原则”</p>
<p>4.亿级IM 4.X</p>
<p>再次遵循了“演化原则”</p>
</p></div><div class="share"><span>Share</span>&nbsp;<span class="soc"><a class="fa fa-bookmark" href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank"></a></span><span class="soc"><a class="fa fa-weibo" href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));"></a></span><span class="soc"><a class="fa fa-twitter" target="_blank" rel="noopener" href="http://twitter.com/home?status=https://yuxue-r.github.io/yuxue-r.io/article/8f889db4.html%20yuxue's blog%20架构"></a></span></div><div class="pagination"><p class="clearfix"><span>&nbsp;</span><span class="next pagbuttons"><a role="navigation" href="/yuxue-r.io/article/cfe6b72b.html" title="第一周随笔">Next post: 第一周随笔&nbsp;<i class="fa fa-angle-double-right"></i></a></span></p></div></div></div></div><div class="visible-xs site-bottom-footer"><footer><p>&copy;&nbsp;2025&nbsp;<a target="_blank" href="https://yuxue-r.github.io/yuxue-r.io" rel="noopener noreferrer">yuxue</a></p><p>Theme&nbsp;<a target="_blank" href="https://github.com/SumiMakito/hexo-theme-typography" rel="noopener noreferrer">Typography</a>&nbsp;by&nbsp;<a target="_blank" href="https://www.keep.moe" rel="noopener noreferrer">Makito</a></p><p>Proudly published with&nbsp;<a target="_blank" href="https://hexo.io" rel="noopener noreferrer">Hexo</a></p></footer></div></div></div></div><script src="/yuxue-r.io/js/jquery-3.1.0.min.js"></script><script src="/yuxue-r.io/js/bootstrap.min.js"></script><script src="/yuxue-r.io/js/jquery-migrate-1.2.1.min.js"></script><script src="/yuxue-r.io/js/jquery.appear.js"></script><script src="/yuxue-r.io/js/google-analytics.js"></script><script src="/yuxue-r.io/js/typography.js"></script></body></html>