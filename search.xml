<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>高并发面试：线程池的七大参数？手写一个线程池？</title>
      <link href="/yuxue-r.io/article/be9ddd6c.html"/>
      <url>/yuxue-r.io/article/be9ddd6c.html</url>
      
        <content type="html"><![CDATA[<h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><h2 id="1-Callable接口的使用"><a href="#1-Callable接口的使用" class="headerlink" title="1. Callable接口的使用"></a>1. Callable接口的使用</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>yuxue<span class="token punctuation">.</span>juc<span class="token punctuation">.</span>threadPool</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span></span><span class="token class-name">Callable</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span></span><span class="token class-name">ExecutionException</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span></span><span class="token class-name">FutureTask</span></span><span class="token punctuation">;</span><span class="token comment">/** * 多线程中，第三种获得多线程的方式 * */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CallableTest</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">ExecutionException</span><span class="token punctuation">,</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>        <span class="token comment">//FutureTask(Callable&lt;V&gt; callable)</span>        <span class="token class-name">FutureTask</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> futureTask <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FutureTask</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">myThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>futureTask<span class="token punctuation">,</span> <span class="token string">"AAA"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//new Thread(futureTask, "BBB").start();//复用，直接取值，不要重启两个线程</span>        <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token comment">//b = futureTask.get();//要求获得Callable线程的计算结果，如果没有计算完成就要去强求，会导致堵塞，直到计算完成</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>futureTask<span class="token punctuation">.</span><span class="token function">isDone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment">////当futureTask完成后取值</span>            b <span class="token operator">=</span> futureTask<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"===Result is:"</span> <span class="token operator">+</span> <span class="token punctuation">(</span>a <span class="token operator">+</span> b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> myThread <span class="token keyword">implements</span> <span class="token class-name">Callable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token class-name">Integer</span> <span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"\tget in the callable"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">5000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token number">1024</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>两者区别：</p><ul><li>Callable：有返回值，抛异常</li><li>Runnable：无返回值，不抛出异常</li></ul><h2 id="2-为什么要使用线程池"><a href="#2-为什么要使用线程池" class="headerlink" title="2. 为什么要使用线程池"></a>2. 为什么要使用线程池</h2><ol><li><p>线程池做的工作主要是控制运行的线程的数量，处理过程中将任务放入队列，然后在线程创建后启动给这些任务，如果线程数量超过了最大数量，超出数量的线程排队等候，等其他线程执行完毕，再从队列中取出任务来执行</p></li><li><p>主要特点</p><p>线程复用、控制最大并发数、管理线程</p><ul><li>减少创建和销毁线程上所花的时间以及系统资源的开销 =&gt; 减少内存开销，创建线程占用内存，创建线程需要时间，会延迟处理的请求；降低资源消耗，通过重复利用已创建的线程降低线程创建和销毁造成的消耗</li><li>提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行</li><li>提高线程的客观理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控（根据系统承受能力，达到运行的最佳效果） =&gt; 避免无限创建线程引起的<code>OutOfMemoryError</code>【简称OOM】</li></ul></li></ol><h2 id="3-线程池如何使用？"><a href="#3-线程池如何使用？" class="headerlink" title="3. 线程池如何使用？"></a>3. 线程池如何使用？</h2><ol><li><p>架构说明</p><p>Java中的线程池是通过Executor框架实现的，该框架中用到了 ：<code>Executor,Executors,ExecutorService,ThreadPoolExecutor</code></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gsd6bhmgmqj30kn0fbtj7.jpg" alt="image-20210711181248546"></p></li><li><p>编码实现</p><p>实现有五种，<code>Executors.newScheduledThreadPool()</code>是带时间调度的，java8新推出</p><p><code>Executors.newWorkStealingPool(int)</code>,使用目前机器上可用的处理器作为他的并行级别</p><p>重点有三种</p><ul><li><p><code>Executors.newFixedThreadPool(int)</code></p><p><strong>执行长期的任务，性能好很多</strong></p><p>创建一个定长线程池，可控制线程最大并发数，超出的线程回在队列中等待newFixedThreadPool创建的线程池corePoolSize和maximumPoolSize值是相等的，它使用的是 LinkedBlockingQueue</p><p>底层源码：</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gsd6csyzipj30k408zdmu.jpg" alt="image-20210711181410391"></p></li><li><p><code>Executors.newSingleThreadExecutor()</code></p><p><strong>一个任务一个任务执行的场景</strong></p><p>创建一个单线程话的线程池，他只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序执行</p><p>newSingleThreadExecutor将corePoolSize和maximumPoolSize都设置为1，使用LinkedBlockingQueue</p><p>源码：</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gsd6czsaqpj30kh0940u5.jpg" alt="image-20210711181321383"></p></li><li><p><code>Executors.newCachedThreadPool()</code></p><p><strong>执行很多短期异步的小程序或负载较轻的服务器</strong></p><p>创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲县城，若无可回收，则新建线程</p><p>newCachedThreadPool将corePoolSize设置为0，将maximumPoolSize设置为Integer.MAX_VALUE,使用 的SynchronousQueue,也就是说来了任务就创建线程运行，当县城空闲超过60s，就销毁线程</p><p>源码：</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gsd6dllescj30k909b7bq.jpg" alt="image-20210711181456304"></p></li></ul><p>我们可以看到底层的代码都是由ThreadPoolExecutor这个类的构造方法创建的，只是传入的参数不同，那么研究一下这个类以及这些参数就很有必要，下节我们将介绍这些参数的使用</p></li><li><p>ThreadPoolExecutor</p></li></ol><h2 id="4-线程池的几个重要参数"><a href="#4-线程池的几个重要参数" class="headerlink" title="4. 线程池的几个重要参数"></a>4. 线程池的几个重要参数</h2><p>核心执行代码为：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token keyword">int</span> corePoolSize<span class="token punctuation">,</span>                          <span class="token keyword">int</span> maximumPoolSize<span class="token punctuation">,</span>                          <span class="token keyword">long</span> keepAliveTime<span class="token punctuation">,</span>                          <span class="token class-name">TimeUnit</span> unit<span class="token punctuation">,</span>                          <span class="token class-name">BlockingQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Runnable</span><span class="token punctuation">&gt;</span></span> workQueue<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">this</span><span class="token punctuation">(</span>corePoolSize<span class="token punctuation">,</span> maximumPoolSize<span class="token punctuation">,</span> keepAliveTime<span class="token punctuation">,</span> unit<span class="token punctuation">,</span> workQueue<span class="token punctuation">,</span>       <span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">defaultThreadFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> defaultHandler<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>那么我们再点进this方法可以看到其全参数的构造方法为：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token keyword">int</span> corePoolSize<span class="token punctuation">,</span>                          <span class="token keyword">int</span> maximumPoolSize<span class="token punctuation">,</span>                          <span class="token keyword">long</span> keepAliveTime<span class="token punctuation">,</span>                          <span class="token class-name">TimeUnit</span> unit<span class="token punctuation">,</span>                          <span class="token class-name">BlockingQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Runnable</span><span class="token punctuation">&gt;</span></span> workQueue<span class="token punctuation">,</span>                          <span class="token class-name">ThreadFactory</span> threadFactory<span class="token punctuation">,</span>                          <span class="token class-name">RejectedExecutionHandler</span> handler<span class="token punctuation">)</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>简单介绍一下：</p><ol><li><p>==corePoolSize:== 线程池中常驻核心线程数</p><ul><li>在创建了线程池后，当有请求任务来之后，就会安排池中的线程去执行请求任务</li><li>当线程池的线程数达到corePoolSize后，就会把到达的任务放到缓存队列当中</li></ul></li><li><p>==maximumPoolSize:== 线程池能够容纳同时执行的最大线程数，必须大于等于1</p></li><li><p>==keepAliveTime:== 多余的空闲线程的存活时间</p><ul><li>当前线程池数量超过corePoolSize时，档口空闲时间达到keepAliveTime值时，多余空闲线程会被销毁到只剩下corePoolSize个线程为止</li></ul></li><li><p>==unit:== keepAliveTime的单位</p></li><li><p>==workQueue:== 任务队列，被提交但尚未被执行的任务</p><p>任务队列底层是BlockingQueue阻塞队列！不清楚阻塞队列的参考这篇文章：<a href="https://www.cnblogs.com/yuxueyyz/p/14994915.html">用阻塞队列实现一个生产者消费者模型？</a></p></li><li><p>==threadFactory:==表示生成线程池中工作线程的线程工厂，用于创建线程一般用默认的即可</p></li><li><p>==handler:== 拒绝策略，表示当队列满了并且工作线程大于等于线程池的最大线程数(maximumPoolSize)时如 何来拒绝请求执行的runable的策略</p></li></ol><h3 id="5-线程池的底层工作原理以及过程"><a href="#5-线程池的底层工作原理以及过程" class="headerlink" title="5. 线程池的底层工作原理以及过程"></a>5. 线程池的底层工作原理以及过程</h3><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gsd6kxrb4nj30t10djgmx.jpg" alt="image-20210711182159169"></p><p>如上图所属，其流程为：</p><ol><li><p>在创建了线程池之后，等待提交过来的任务请求</p></li><li><p>当调用execute()方法添加一个请求任务时，线程池会做出如下判断：</p><p>2.1 如果正在运行的线程数量小于corePoolSize，那么马上创建线程运行这个任务；</p><p>2.2 如果正在运行的线程数量大于或等于corePoolSize，那么将这个任务放入队列；</p><p>2.3 如果此时队列满了且运行的线程数小于maximumPoolSize，那么还是要创建非核心线程立刻运行此任务；</p><p>2.4 如果队列满了且正在运行的线程数量大于或等于maxmumPoolSize，那么启动饱和拒绝策略来执行</p></li><li><p>当一个线程完成任务时，他会从队列中取出下一个任务来执行</p></li><li><p>当一个线程无事可做超过一定的时间(keepAliveTime)时，线程池会判断：</p><p>如果当前运行的线程数大于corePoolSize，那么这个线程会被停掉;所以线程池的所有任务完成后他最大会收 缩到corePoolSize的大小</p></li></ol><h2 id="5-实际工作中如何设置合理参数"><a href="#5-实际工作中如何设置合理参数" class="headerlink" title="5. 实际工作中如何设置合理参数"></a>5. 实际工作中如何设置合理参数</h2><h3 id="5-1-线程池的拒绝策略"><a href="#5-1-线程池的拒绝策略" class="headerlink" title="5.1 线程池的拒绝策略"></a>5.1 线程池的拒绝策略</h3><ol><li>什么是线程的拒绝策略<ol><li>等待队列也已经排满了，再也塞不下新任务了，同时线程池中的max线程也达到了，无法继续为新任务服务。这时我们就需要拒绝策略机制合理的处理这个问题</li></ol></li><li>JDK内置的拒绝策略<ul><li>AbortPolicy(默认)：如果满了会直接抛出RejectedExecutionException异常阻止系统正常运行</li><li>CallerRunsPolicy：”调用者运行“一种调节机制，该策略既不会抛弃任务，也不会抛出异常，而是将某些任务回退到调用者， 从而降低新任务的流量</li><li>DiscardOldestPolicy：抛弃队列中等待最久的任务，然后把当前任务加入队列中尝试再次提交当前任务</li><li>DiscardPolicy：直接丢弃任务，不予任何处理也不抛异常。如果允许任务丢失，这是最好的一种方案</li></ul></li><li>均实现了RejectedExecutionHandler接口</li></ol><h3 id="5-2-你在工作中单一的-固定数的-可变的三种创建线程池的方法，用哪个多？"><a href="#5-2-你在工作中单一的-固定数的-可变的三种创建线程池的方法，用哪个多？" class="headerlink" title="5.2 你在工作中单一的/固定数的/可变的三种创建线程池的方法，用哪个多？"></a>5.2 你在工作中单一的/固定数的/可变的三种创建线程池的方法，用哪个多？</h3><p>回答：<strong>==一个都不用，我们生产上只能使用自定义的!!!!==</strong></p><p>为什么? </p><p>线程池不允许使用Executors创建，试试通过ThreadPoolExecutor的方式，规避资源耗尽风险</p><p>阿里巴巴规范手册当中提到：</p><ul><li>FixedThreadPool和SingleThreadPool允许请求队列长度为Integer.MAX_VALUE，可能会堆积大量请求，导致OOM;</li><li>CachedThreadPool和ScheduledThreadPool允许的创建线程数量为Integer.MAX_VALUE，可能会创建大量线程，导致OOM</li></ul><h3 id="5-3-你在工作中时如何使用线程池的，是否自定义过线程池？"><a href="#5-3-你在工作中时如何使用线程池的，是否自定义过线程池？" class="headerlink" title="5.3 你在工作中时如何使用线程池的，是否自定义过线程池？"></a>5.3 你在工作中时如何使用线程池的，是否自定义过线程池？</h3><p>上代码：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>yuxue<span class="token punctuation">.</span>juc<span class="token punctuation">.</span>threadPool</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span></span><span class="token class-name">Executors</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span></span><span class="token class-name">LinkedBlockingQueue</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span></span><span class="token class-name">ThreadPoolExecutor</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span></span><span class="token class-name">TimeUnit</span></span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyThreadPoolDemo</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">ThreadPoolExecutor</span> threadPoolExecutor <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span>                <span class="token comment">//corePoolSize:常驻核心线程数</span>                <span class="token number">2</span><span class="token punctuation">,</span>                <span class="token comment">//maximumPoolSize:最大的可容纳线程数</span>                <span class="token number">5</span><span class="token punctuation">,</span>                <span class="token comment">//存活时间设置为1s</span>                <span class="token number">1L</span><span class="token punctuation">,</span>                <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">SECONDS</span><span class="token punctuation">,</span>                <span class="token comment">//这里用LinkedBlockingQueue，且容量为3，意味着等候区最大容量三个任务</span>                <span class="token keyword">new</span> <span class="token class-name">LinkedBlockingQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                <span class="token comment">//默认的defaultThreadFactory即可</span>                <span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">defaultThreadFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                <span class="token comment">//丢弃方法使用AbortPolicy()</span>                <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor<span class="token punctuation">.</span>AbortPolicy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//这里用来做任务的处理执行</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            threadPoolExecutor<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span><span class="token punctuation">{</span>                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"\t 办理业务；"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        threadPoolExecutor<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们运行结果为：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">2</span> 办理业务；pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">1</span> 办理业务；pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">2</span> 办理业务；pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">1</span> 办理业务；pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">2</span> 办理业务；<span class="token comment">//可以看到当我们任务书为5且处理速度非常快时，我们就用核心的corePoolSize就可以满足任务需求</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当任务数量变多或者任务变重时：如将我们的任务数量调整为20时，此时运行结果为：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">1</span> 办理业务；pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">3</span> 办理业务；pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">2</span> 办理业务；pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">3</span> 办理业务；pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">1</span> 办理业务；pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">4</span> 办理业务；pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">1</span> 办理业务；pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">3</span> 办理业务；pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">2</span> 办理业务；pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">5</span> 办理业务；pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">4</span> 办理业务；pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">1</span> 办理业务；pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">3</span> 办理业务；pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">1</span> 办理业务；pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">2</span> 办理业务；<span class="token class-name">Exception</span> in thread <span class="token string">"main"</span> <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span></span>RejectedExecutionException</span><span class="token operator">:</span> <span class="token class-name">Task</span> <span class="token class-name"><span class="token namespace">com<span class="token punctuation">.</span>yuxue<span class="token punctuation">.</span>juc<span class="token punctuation">.</span>threadPool<span class="token punctuation">.</span></span>MyThreadPoolDemo</span>$$<span class="token class-name">Lambda</span>$<span class="token number">1</span><span class="token operator">/</span><span class="token number">558638686</span><span class="token annotation punctuation">@6d03e736</span> rejected from <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span></span>ThreadPoolExecutor</span><span class="token annotation punctuation">@568db2f2</span><span class="token punctuation">[</span><span class="token class-name">Running</span><span class="token punctuation">,</span> pool size <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">,</span> active threads <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> queued tasks <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> completed tasks <span class="token operator">=</span> <span class="token number">15</span><span class="token punctuation">]</span>at <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span></span>ThreadPoolExecutor</span>$<span class="token class-name">AbortPolicy</span><span class="token punctuation">.</span><span class="token function">rejectedExecution</span><span class="token punctuation">(</span><span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">2063</span><span class="token punctuation">)</span>at <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span></span>ThreadPoolExecutor</span><span class="token punctuation">.</span><span class="token function">reject</span><span class="token punctuation">(</span><span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">830</span><span class="token punctuation">)</span>at <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span></span>ThreadPoolExecutor</span><span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">1379</span><span class="token punctuation">)</span>at <span class="token class-name"><span class="token namespace">com<span class="token punctuation">.</span>yuxue<span class="token punctuation">.</span>juc<span class="token punctuation">.</span>threadPool<span class="token punctuation">.</span></span>MyThreadPoolDemo</span><span class="token punctuation">.</span><span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">MyThreadPoolDemo</span><span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">27</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>发生了异常，且任务只执行完了15个，我们可以看到其中active threads = 0, queued tasks = 0也就是说我的阻塞队列已经满了，且没有空闲的线程了，此时再申请任务我就会抛出异常，这是线程池handler参数的拒绝策略，当我们更改策略为<code>ThreadPoolExecutor.CallerRunsPolicy()</code>时，运行结果当中存在<code>main 办理业务；</code>语句，也就意味着线程池将某些任务回退到了调用者，另外的两个拒绝策略在此就不演示</p><h3 id="5-4-合理配置线程池你是如何考虑的"><a href="#5-4-合理配置线程池你是如何考虑的" class="headerlink" title="5.4 合理配置线程池你是如何考虑的?"></a>5.4 合理配置线程池你是如何考虑的?</h3><ol><li><p>CPU密集型：</p><ul><li>CPU密集的意思是该任务需要大量的运算，而没有阻塞，CPU一直全速运行</li><li>CPU密集任务只有在真正多核CPU上才可能得到加速(通过多线程) 而在单核CPU上，无论你开几个模拟的多线程该任务都不可能得到加速，因为CPU总的运算能力就那些</li><li>CPU密集型任务配置尽可能少的线程数量</li></ul><p><strong>==一般公式:CPU核数+1个线程的线程池==</strong></p></li><li><p>IO密集型</p><ul><li>由于IO密集型任务线程并不是一直在执行任务，则应配置经可能多的线程，如CPU核数 * 2</li><li>IO密集型，即该任务需要大量的IO，即大量的阻塞。在单线程上运行IO密集型的任务会导致浪费大量的 CPU运算能力浪费在等待。</li><li>所以在IO密集型任务中使用多线程可以大大的加速程序运行，即使在单核CPU上，这种加速主要就是利用 了被浪费掉的阻塞时间。</li><li>IO密集型时，大部分线程都阻塞，故需要多配置线程数:</li></ul><p><strong>==参考公式:CPU核数/(1-阻塞系数) 阻塞系数在0.8~0.9之间==</strong></p></li></ol><p>例如八核CPU:，利用公式，约为：8/(1-0，9)=80个线程</p>]]></content>
      
      
      <categories>
          
          <category> 高并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并发, 线程池, 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>架构</title>
      <link href="/yuxue-r.io/article/8f889db4.html"/>
      <url>/yuxue-r.io/article/8f889db4.html</url>
      
        <content type="html"><![CDATA[<h1 id="架构设计的目的"><a href="#架构设计的目的" class="headerlink" title="架构设计的目的"></a>架构设计的目的</h1><ul><li>为了高性能、高可用、可扩展，所以要做架构设计</li></ul><p>能够给出这个答案，说明已经有了一定的架构经历或者基础，毕竟确实很多架构设计都是冲着高性能、高可用……等“高XX”的目标去的。</p><p>但往往持有这类观点的架构师和设计师会给项目带来巨大的灾难</p><h2 id="架构设计的真正目的"><a href="#架构设计的真正目的" class="headerlink" title="架构设计的真正目的"></a>架构设计的真正目的</h2><p>通过回顾架构产生的历史背景和原因，我们可以基本推导出答案：<strong>架构设计的主要目的是为了解决软件系统复杂度带来的问题</strong>。</p><ul><li>“这么多需求，从哪里开始下手进行架构设计呢？”</li></ul><p>——通过熟悉和理解需求，识别系统复杂性所在的地方，然后针对这些复杂点进行架构设计。</p><ul><li>“架构设计要考虑高性能、高可用、高扩展……这么多高XX，全部设计完成估计要1个月，但老大只给了1周时间”</li></ul><p>——架构设计并不是要面面俱到，不需要每个架构都具备高性能、高可用、高扩展等特点，而是要识别出复杂点然后有针对性地解决问题。</p><ul><li>“业界A公司的架构是X，B公司的方案是Y，两个差别比较大，该参考哪一个呢？”</li></ul><p>——理解每个架构方案背后所需要解决的复杂点，然后才能对比自己的业务复杂点，参考复杂点相似的方案。</p><p>其次，遵循这条准则能够让“老鸟”架构师<strong>有的放矢，而不是贪大求全</strong>。</p><ul><li>Docker不是万能的，只是为了解决资源重用和动态分配而设计的</li></ul><h2 id="简单的复杂度分析案例"><a href="#简单的复杂度分析案例" class="headerlink" title="简单的复杂度分析案例"></a>简单的复杂度分析案例</h2><p>假设我们需要设计一个大学的学生管理系统，其基本功能包括登录、注册、成绩管理、课程管理等。当我们对这样一个系统进行架构设计的时候，首先应识别其复杂度到底体现在哪里。</p><p>性能：一个学校的学生大约1 ~ 2万人，学生管理系统的访问频率并不高，平均每天单个学生的访问次数平均不到1次，因此性能这部分并不复杂，存储用MySQL完全能够胜任，缓存都可以不用，Web服务器用Nginx绰绰有余。</p><p>可扩展性：学生管理系统的功能比较稳定，可扩展的空间并不大，因此可扩展性也不复杂。</p><p>高可用：学生管理系统即使宕机2小时，对学生管理工作影响并不大，因此可以不做负载均衡，更不用考虑异地多活这类复杂的方案了。但是，如果学生的数据全部丢失，修复是非常麻烦的，只能靠人工逐条修复，这个很难接受，因此需要考虑存储高可靠，这里就有点复杂了。我们需要考虑多种异常情况：机器故障、机房故障，针对机器故障，我们需要设计MySQL同机房主备方案；针对机房故障，我们需要设计MySQL跨机房同步方案。</p><p>安全性：学生管理系统存储的信息有一定的隐私性，例如学生的家庭情况，但并不是和金融相关的，也不包含强隐私（例如玉照、情感）的信息，因此安全性方面只要做3个事情就基本满足要求了：Nginx提供ACL控制、用户账号密码管理、数据库访问权限控制。</p><p>成本：由于系统很简单，基本上几台服务器就能够搞定，对于一所大学来说完全不是问题，可以无需太多关注。</p><p>还有其他方面，如果有兴趣，你可以自行尝试去分析。通过我上面的分析，可以看到这个方案的主要复杂性体现在存储可靠性上，需要保证异常的时候，不要丢失所有数据即可（丢失几个或者几十个学生的信息问题不大），对应的架构如下：</p><p><img src="https://github.com/yuxue-r/pic/blob/master/2025/1725783793484-e9d01b71-db1c-4b5a-9f3a-a8cd30b8fbaf.png?raw=true" alt="1725783793484-e9d01b71-db1c-4b5a-9f3a-a8cd30b8fbaf.png"></p><p>学生管理系统虽然简单，但麻雀虽小五脏俱全，基本上能涵盖软件系统复杂度分析的各个方面，而且绝大部分技术人员都曾经自己设计或者接触过类似的系统，如果将这个案例和自己的经验对比，相信会有更多的收获。</p><h1 id="08-架构设计三原则"><a href="#08-架构设计三原则" class="headerlink" title="08 架构设计三原则"></a>08 架构设计三原则</h1><p>相比编程来说，架构设计并没有像编程语言那样的语法来进行约束，更多的时候是面对多种可能性时进行选择。</p><p>可是一旦涉及“选择”，就很容易让架构师陷入两难的境地</p><p><strong>合适原则、简单原则、演化原则</strong>，架构设计时遵循这几个原则，有助于你做出最好的选择。</p><h2 id="合适原则"><a href="#合适原则" class="headerlink" title="合适原则"></a>合适原则</h2><p><strong>合适原则宣言：“合适优于业界领先”</strong></p><p><strong>没那么多人，却想干那么多活，是失败的第一个主要原因</strong></p><p><strong>没有那么多积累，却想一步登天，是失败的第二个主要原因</strong></p><p><strong>没有那么卓越的业务场景，却幻想灵光一闪成为天才，是失败的第三个主要原因</strong></p><h2 id="简单原则"><a href="#简单原则" class="headerlink" title="简单原则"></a>简单原则</h2><p><strong>简单原则宣言：“简单优于复杂”</strong></p><p>例如设计一个主备方案，如果你用心跳来实现，可能大家都认为这太简单了。但如果你引入ZooKeeper来做主备决策，可能很多人会认为这个方案更加“高大上”一些，毕竟ZooKeeper使用的是ZAB协议，而ZAB协议本身就很复杂。其实，真正理解ZAB协议的人很少（我也不懂），但并不妨碍我们都知道ZAB协议很优秀。</p><p>1.结构复杂性</p><p>结构上的复杂性存在的第一个问题是，<strong>组件越多，就越有可能其中某个组件出现故障</strong></p><p>结构上的复杂性存在的第二个问题是，<strong>某个组件改动，会影响关联的所有组件</strong></p><p>结构上的复杂性存在的第三个问题是，<strong>定位一个复杂系统中的问题总是比简单系统更加困难</strong></p><p>2.逻辑复杂性</p><p>不要把所有的代码和逻辑都扔进一个结构（这里的结构主要指系统）里</p><p>以ZooKeeper为例，ZooKeeper本身的功能主要就是选举，为了实现分布式下的选举，采用了ZAB协议，所以ZooKeeper功能虽然相对简单，但系统实现却比较复杂。相比之下，etcd就要简单一些，因为etcd采用的是Raft算法，相比ZAB协议，Raft算法更加容易理解，更加容易实现。</p><h2 id="演化原则"><a href="#演化原则" class="headerlink" title="演化原则"></a>演化原则</h2><p><strong>演化原则宣言：“演化优于一步到位”</strong></p><p>如果没有把握“软件架构需要根据业务发展不断变化”这个本质，在做架构设计的时候就很容易陷入一个误区：试图一步到位设计一个软件架构，期望不管业务如何变化，架构都稳如磐石</p><p><strong>软件架构设计其实更加类似于大自然“设计”一个生物，通过演化让生物适应环境，逐步变得更加强大</strong></p><p>软件架构设计同样是类似的过程：</p><ul><li>首先，设计出来的架构要满足当时的业务需要。</li><li>其次，架构要不断地在实际应用过程中迭代，保留优秀的设计，修复有缺陷的设计，改正错误的设计，去掉无用的设计，使得架构逐渐完善。</li><li>第三，当业务发生变化时，架构要扩展、重构，甚至重写；代码也许会重写，但有价值的经验、教训、逻辑、设计等（类似生物体内的基因）却可以在新架构中延续。</li></ul><h1 id="09-架构设计原则案例"><a href="#09-架构设计原则案例" class="headerlink" title="09 架构设计原则案例"></a>09 架构设计原则案例</h1><h2 id="淘宝"><a href="#淘宝" class="headerlink" title="淘宝"></a>淘宝</h2><p>1.最早的版本当时淘宝是买来的，要求快速可用</p><p><strong>买一个系统是为了“快速可用”，而买一个轻量级的系统是为了“快速开发”</strong>。因为系统上线后肯定有大量的需求需要做，这时能够快速开发就非常重要</p><p>淘宝最开始的时候业务要求就是“快”，因此反过来要求技术同样要“快”，业务决定技术，这里架构设计和选择主要遵循的是“合适原则”和“简单原则”</p><p>2.当用户访问量上升之后，淘宝首先把数据库从MySQL更换为了Oracle</p><p>此时离刚上线才半年不到，业务飞速发展，最快的方式支撑业务的发展还是去买。如果说第一阶段买的是“方案”，这个阶段买的就是“性能”，这里架构设计和选择主要遵循的还是“合适原则”和“简单原则”</p><p>3.Java1.0版本，当时从PHP升级为Java语言</p><p>首先因为Java较火，懂得该技术的人相对较多，较好维护，好招人</p><p>此时就遵循了三大原则的“演化原则”，通过重构来解决</p><p>4.Java2.0版本</p><p>Java时代2.0，淘宝做了很多优化工作：数据分库、放弃EJB、引入Spring、加入缓存、加入CDN、采用开源的JBoss。为什么在这个时候要做这些动作？原文作者很好地概括了做这些动作的原因：</p><p>这些杂七杂八的修改，我们对数据分库、放弃EJB、引入Spring、加入缓存、加入CDN、采用开源的JBoss，看起来没有章法可循，其实都是围绕着提高容量、提高性能、节约成本来做的。</p><p>Oracle再强大，在做like类搜索的时候，也不可能做到纯粹的搜索系统如Solr、Sphinx等的性能，因为这是机制决定的。</p><p>5.Java 时代3.0和分布式时代</p><h2 id="手机QQ"><a href="#手机QQ" class="headerlink" title="手机QQ"></a>手机QQ</h2><p>手机QQ的发展历程按照用户规模可以粗略划分为4个阶段：十万级、百万级、千万级、亿级，不同的用户规模，IM后台的架构也不同，而且基本上都是用户规模先上去，然后产生各种问题，倒逼技术架构升级。</p><p>1.十万级IM 1.X</p><p>架构设计遵循的是“合适原则”和“简单原则”</p><p>2.百万级IM 2.X</p><ul><li>以接入服务器的内存为例，单个在线用户的存储量约为2KB，索引和在线状态为50字节，好友表400个好友 × 5字节/好友 = 2000字节，大致来说，2GB内存只能支持一百万在线用户。</li><li>CPU/网卡包量和流量/交换机流量等瓶颈。</li><li>单台服务器支撑不下所有在线用户/注册用户。</li></ul><p>遵循了“合适原则”和“简单原则”</p><p>3.千万级IM 3.X</p><ul><li>同步流量太大，状态同步服务器遇到单机瓶颈。</li><li>所有在线用户的在线状态信息量太大，单台接入服务器存不下，如果在线数进一步增加，甚至单台状态同步服务器也存不下。</li><li>单台状态同步服务器支撑不下所有在线用户。</li><li>单台接入服务器支撑不下所有在线用户的在线状态信息。</li></ul><p>遵循了“演化原则”</p><p>4.亿级IM 4.X</p><p>再次遵循了“演化原则”</p>]]></content>
      
      
      <categories>
          
          <category> 架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一周随笔</title>
      <link href="/yuxue-r.io/article/cfe6b72b.html"/>
      <url>/yuxue-r.io/article/cfe6b72b.html</url>
      
        <content type="html"><![CDATA[<p>20250825 周一</p><p>今天跑了步</p><img src="https://raw.githubusercontent.com/yuxue-r/pic/master/2025/image-20250826002345575.png" alt="image-20250826002345575" style="zoom:25%;">]]></content>
      
      
      <categories>
          
          <category> 周记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 周记 </tag>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
