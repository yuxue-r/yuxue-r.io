<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>架构</title>
      <link href="/yuxue-r.io/article/8f889db4.html"/>
      <url>/yuxue-r.io/article/8f889db4.html</url>
      
        <content type="html"><![CDATA[<h1 id="架构设计的目的"><a href="#架构设计的目的" class="headerlink" title="架构设计的目的"></a>架构设计的目的</h1><ul><li>为了高性能、高可用、可扩展，所以要做架构设计</li></ul><p>能够给出这个答案，说明已经有了一定的架构经历或者基础，毕竟确实很多架构设计都是冲着高性能、高可用……等“高XX”的目标去的。</p><p>但往往持有这类观点的架构师和设计师会给项目带来巨大的灾难</p><h2 id="架构设计的真正目的"><a href="#架构设计的真正目的" class="headerlink" title="架构设计的真正目的"></a>架构设计的真正目的</h2><p>通过回顾架构产生的历史背景和原因，我们可以基本推导出答案：<strong>架构设计的主要目的是为了解决软件系统复杂度带来的问题</strong>。</p><ul><li>“这么多需求，从哪里开始下手进行架构设计呢？”</li></ul><p>——通过熟悉和理解需求，识别系统复杂性所在的地方，然后针对这些复杂点进行架构设计。</p><ul><li>“架构设计要考虑高性能、高可用、高扩展……这么多高XX，全部设计完成估计要1个月，但老大只给了1周时间”</li></ul><p>——架构设计并不是要面面俱到，不需要每个架构都具备高性能、高可用、高扩展等特点，而是要识别出复杂点然后有针对性地解决问题。</p><ul><li>“业界A公司的架构是X，B公司的方案是Y，两个差别比较大，该参考哪一个呢？”</li></ul><p>——理解每个架构方案背后所需要解决的复杂点，然后才能对比自己的业务复杂点，参考复杂点相似的方案。</p><p>其次，遵循这条准则能够让“老鸟”架构师<strong>有的放矢，而不是贪大求全</strong>。</p><ul><li>Docker不是万能的，只是为了解决资源重用和动态分配而设计的</li></ul><h2 id="简单的复杂度分析案例"><a href="#简单的复杂度分析案例" class="headerlink" title="简单的复杂度分析案例"></a>简单的复杂度分析案例</h2><p>假设我们需要设计一个大学的学生管理系统，其基本功能包括登录、注册、成绩管理、课程管理等。当我们对这样一个系统进行架构设计的时候，首先应识别其复杂度到底体现在哪里。</p><p>性能：一个学校的学生大约1 ~ 2万人，学生管理系统的访问频率并不高，平均每天单个学生的访问次数平均不到1次，因此性能这部分并不复杂，存储用MySQL完全能够胜任，缓存都可以不用，Web服务器用Nginx绰绰有余。</p><p>可扩展性：学生管理系统的功能比较稳定，可扩展的空间并不大，因此可扩展性也不复杂。</p><p>高可用：学生管理系统即使宕机2小时，对学生管理工作影响并不大，因此可以不做负载均衡，更不用考虑异地多活这类复杂的方案了。但是，如果学生的数据全部丢失，修复是非常麻烦的，只能靠人工逐条修复，这个很难接受，因此需要考虑存储高可靠，这里就有点复杂了。我们需要考虑多种异常情况：机器故障、机房故障，针对机器故障，我们需要设计MySQL同机房主备方案；针对机房故障，我们需要设计MySQL跨机房同步方案。</p><p>安全性：学生管理系统存储的信息有一定的隐私性，例如学生的家庭情况，但并不是和金融相关的，也不包含强隐私（例如玉照、情感）的信息，因此安全性方面只要做3个事情就基本满足要求了：Nginx提供ACL控制、用户账号密码管理、数据库访问权限控制。</p><p>成本：由于系统很简单，基本上几台服务器就能够搞定，对于一所大学来说完全不是问题，可以无需太多关注。</p><p>还有其他方面，如果有兴趣，你可以自行尝试去分析。通过我上面的分析，可以看到这个方案的主要复杂性体现在存储可靠性上，需要保证异常的时候，不要丢失所有数据即可（丢失几个或者几十个学生的信息问题不大），对应的架构如下：</p><p><img src="https://github.com/yuxue-r/pic/blob/master/2025/1725783793484-e9d01b71-db1c-4b5a-9f3a-a8cd30b8fbaf.png?raw=true" alt="1725783793484-e9d01b71-db1c-4b5a-9f3a-a8cd30b8fbaf.png"></p><p>学生管理系统虽然简单，但麻雀虽小五脏俱全，基本上能涵盖软件系统复杂度分析的各个方面，而且绝大部分技术人员都曾经自己设计或者接触过类似的系统，如果将这个案例和自己的经验对比，相信会有更多的收获。</p><h1 id="08-架构设计三原则"><a href="#08-架构设计三原则" class="headerlink" title="08 架构设计三原则"></a>08 架构设计三原则</h1><p>相比编程来说，架构设计并没有像编程语言那样的语法来进行约束，更多的时候是面对多种可能性时进行选择。</p><p>可是一旦涉及“选择”，就很容易让架构师陷入两难的境地</p><p><strong>合适原则、简单原则、演化原则</strong>，架构设计时遵循这几个原则，有助于你做出最好的选择。</p><h2 id="合适原则"><a href="#合适原则" class="headerlink" title="合适原则"></a>合适原则</h2><p><strong>合适原则宣言：“合适优于业界领先”</strong></p><p><strong>没那么多人，却想干那么多活，是失败的第一个主要原因</strong></p><p><strong>没有那么多积累，却想一步登天，是失败的第二个主要原因</strong></p><p><strong>没有那么卓越的业务场景，却幻想灵光一闪成为天才，是失败的第三个主要原因</strong></p><h2 id="简单原则"><a href="#简单原则" class="headerlink" title="简单原则"></a>简单原则</h2><p><strong>简单原则宣言：“简单优于复杂”</strong></p><p>例如设计一个主备方案，如果你用心跳来实现，可能大家都认为这太简单了。但如果你引入ZooKeeper来做主备决策，可能很多人会认为这个方案更加“高大上”一些，毕竟ZooKeeper使用的是ZAB协议，而ZAB协议本身就很复杂。其实，真正理解ZAB协议的人很少（我也不懂），但并不妨碍我们都知道ZAB协议很优秀。</p><p>1.结构复杂性</p><p>结构上的复杂性存在的第一个问题是，<strong>组件越多，就越有可能其中某个组件出现故障</strong></p><p>结构上的复杂性存在的第二个问题是，<strong>某个组件改动，会影响关联的所有组件</strong></p><p>结构上的复杂性存在的第三个问题是，<strong>定位一个复杂系统中的问题总是比简单系统更加困难</strong></p><p>2.逻辑复杂性</p><p>不要把所有的代码和逻辑都扔进一个结构（这里的结构主要指系统）里</p><p>以ZooKeeper为例，ZooKeeper本身的功能主要就是选举，为了实现分布式下的选举，采用了ZAB协议，所以ZooKeeper功能虽然相对简单，但系统实现却比较复杂。相比之下，etcd就要简单一些，因为etcd采用的是Raft算法，相比ZAB协议，Raft算法更加容易理解，更加容易实现。</p><h2 id="演化原则"><a href="#演化原则" class="headerlink" title="演化原则"></a>演化原则</h2><p><strong>演化原则宣言：“演化优于一步到位”</strong></p><p>如果没有把握“软件架构需要根据业务发展不断变化”这个本质，在做架构设计的时候就很容易陷入一个误区：试图一步到位设计一个软件架构，期望不管业务如何变化，架构都稳如磐石</p><p><strong>软件架构设计其实更加类似于大自然“设计”一个生物，通过演化让生物适应环境，逐步变得更加强大</strong></p><p>软件架构设计同样是类似的过程：</p><ul><li>首先，设计出来的架构要满足当时的业务需要。</li><li>其次，架构要不断地在实际应用过程中迭代，保留优秀的设计，修复有缺陷的设计，改正错误的设计，去掉无用的设计，使得架构逐渐完善。</li><li>第三，当业务发生变化时，架构要扩展、重构，甚至重写；代码也许会重写，但有价值的经验、教训、逻辑、设计等（类似生物体内的基因）却可以在新架构中延续。</li></ul><h1 id="09-架构设计原则案例"><a href="#09-架构设计原则案例" class="headerlink" title="09 架构设计原则案例"></a>09 架构设计原则案例</h1><h2 id="淘宝"><a href="#淘宝" class="headerlink" title="淘宝"></a>淘宝</h2><p>1.最早的版本当时淘宝是买来的，要求快速可用</p><p><strong>买一个系统是为了“快速可用”，而买一个轻量级的系统是为了“快速开发”</strong>。因为系统上线后肯定有大量的需求需要做，这时能够快速开发就非常重要</p><p>淘宝最开始的时候业务要求就是“快”，因此反过来要求技术同样要“快”，业务决定技术，这里架构设计和选择主要遵循的是“合适原则”和“简单原则”</p><p>2.当用户访问量上升之后，淘宝首先把数据库从MySQL更换为了Oracle</p><p>此时离刚上线才半年不到，业务飞速发展，最快的方式支撑业务的发展还是去买。如果说第一阶段买的是“方案”，这个阶段买的就是“性能”，这里架构设计和选择主要遵循的还是“合适原则”和“简单原则”</p><p>3.Java1.0版本，当时从PHP升级为Java语言</p><p>首先因为Java较火，懂得该技术的人相对较多，较好维护，好招人</p><p>此时就遵循了三大原则的“演化原则”，通过重构来解决</p><p>4.Java2.0版本</p><p>Java时代2.0，淘宝做了很多优化工作：数据分库、放弃EJB、引入Spring、加入缓存、加入CDN、采用开源的JBoss。为什么在这个时候要做这些动作？原文作者很好地概括了做这些动作的原因：</p><p>这些杂七杂八的修改，我们对数据分库、放弃EJB、引入Spring、加入缓存、加入CDN、采用开源的JBoss，看起来没有章法可循，其实都是围绕着提高容量、提高性能、节约成本来做的。</p><p>Oracle再强大，在做like类搜索的时候，也不可能做到纯粹的搜索系统如Solr、Sphinx等的性能，因为这是机制决定的。</p><p>5.Java 时代3.0和分布式时代</p><h2 id="手机QQ"><a href="#手机QQ" class="headerlink" title="手机QQ"></a>手机QQ</h2><p>手机QQ的发展历程按照用户规模可以粗略划分为4个阶段：十万级、百万级、千万级、亿级，不同的用户规模，IM后台的架构也不同，而且基本上都是用户规模先上去，然后产生各种问题，倒逼技术架构升级。</p><p>1.十万级IM 1.X</p><p>架构设计遵循的是“合适原则”和“简单原则”</p><p>2.百万级IM 2.X</p><ul><li>以接入服务器的内存为例，单个在线用户的存储量约为2KB，索引和在线状态为50字节，好友表400个好友 × 5字节/好友 = 2000字节，大致来说，2GB内存只能支持一百万在线用户。</li><li>CPU/网卡包量和流量/交换机流量等瓶颈。</li><li>单台服务器支撑不下所有在线用户/注册用户。</li></ul><p>遵循了“合适原则”和“简单原则”</p><p>3.千万级IM 3.X</p><ul><li>同步流量太大，状态同步服务器遇到单机瓶颈。</li><li>所有在线用户的在线状态信息量太大，单台接入服务器存不下，如果在线数进一步增加，甚至单台状态同步服务器也存不下。</li><li>单台状态同步服务器支撑不下所有在线用户。</li><li>单台接入服务器支撑不下所有在线用户的在线状态信息。</li></ul><p>遵循了“演化原则”</p><p>4.亿级IM 4.X</p><p>再次遵循了“演化原则”</p>]]></content>
      
      
      <categories>
          
          <category> 架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一周随笔</title>
      <link href="/yuxue-r.io/article/cfe6b72b.html"/>
      <url>/yuxue-r.io/article/cfe6b72b.html</url>
      
        <content type="html"><![CDATA[<p>20250825 周一</p><p>今天跑了步</p><img src="https://raw.githubusercontent.com/yuxue-r/pic/master/2025/image-20250826002345575.png" alt="image-20250826002345575" style="zoom:25%;">]]></content>
      
      
      <categories>
          
          <category> 周记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 周记 </tag>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
